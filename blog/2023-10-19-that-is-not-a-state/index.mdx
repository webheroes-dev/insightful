---
slug: that-is-not-a-state
title: That's not a state (anymore)
authors: [krystian, barbie]
tags: [react, state]
draft: true
---

Handle state properly

...

# DRAFT
- common mistakes
    - synchronizing on event
- derive from props
- derive from state
- derive from url
- opened tab id from url


<!--truncate-->

## problem: need to combine props together

common mistake: synchronizing with use of `useEffect` and `useState`

```tsx showLineNumbers
interface Props {
    firstName: string
    lastName: string
}
function Component(props: Props) {
    const {firstName, lastName} = props

    const [fullName, setFullName] = useState()

    useEffect(() => {
        setFullName(`${firstName} ${lastName}`)
    }, [firstName, lastName])
}
```

solution: derive value from props

```tsx showLineNumbers
interface Props {
    firstName: string
    lastName: string
}
function Component(props: Props) {
    const {firstName, lastName} = props

    // highlight-next-line
    const fullName = `${firstName} ${lastName}` // ✨
}
```

## problem: need to combine states

common mistake: synchronizing with use of `useEffect` and extra `useState`


```tsx showLineNumbers
function Component() {
    const [firstName, setFirstName] = useState()
    const [lastName, setLastName] = useState()

    const [fullName, setFullName] = useState()

    useEffect(() => {
        setFullName(`${firstName} ${lastName}`)
    }, [firstName, lastName])
}
```

solution: derive from current state

```tsx showLineNumbers
function Component() {
    const [firstName, setFirstName] = useState()
    const [lastName, setLastName] = useState()

    // highlight-next-line
    const fullName = `${firstName} ${lastName}` // ✨
}
```

## problem: many related states

common mistake: many React states

```tsx showLineNumbers
function Component() {
    const [loading, setLoading] = useState()
    const [data, setData] = useState()
    const [error, setError] = useState()

    function load() {
        setLoading(true)

        fetch(/* ... */)
        .then((data) => {
            setData(data)
            // highlight-next-line
            setLoading(false)
        })
        .catch((error) => {
            setError(error)
            //highlight-next-line
            setLoading(false)
        })
    }
}
```

`setLoading` needs to be called along with `setData` and `setError`

above may also lead to bugs
- when `setData` is called, we should clean `error` state
- when `setError` is called, we may clean `data` state

```tsx showLineNumbers
function Component() {
    const [loading, setLoading] = useState()
    const [data, setData] = useState()
    const [error, setError] = useState()

    function load() {
        setLoading(true)

        fetch(/* ... */)
        .then((data) => {
            setData(data)
            setLoading(false)
            // highlight-next-line
            setError(null)
        })
        .catch((error) => {
            setError(error)
            setLoading(false)
            // highlight-next-line
            setData(null)
        })
    }
}
```

could be even worse

solution: use underrated `useReducer`

```tsx showLineNumbers
const [response, setResponse] = useReducer((lastResponse, payload) => {
    if (payload === null) {
        return {
            loading: true,
            data: null,
            error: null,
        }
    } else if (payload instanceof Error) {
        return {
            loading: false,
            data: null,
            error: payload,
        }
    } else {
        return {
            loading: false,
            data: payload,
            error: null,
        }
    }
})

function load() {
    setResponse(null)

    fetch(/* ... */)
    .then((data) => setResponse(data))
    .catch((error) => setResponse(error))
}
```

perks: we don't need to manage every single state individually

with use of first parameter of reducer function we can make it to return loading state along with previously fetched data (e.g. for refreshing purposes with an indicator)

## problem: filtering on a page

challenges:
- refreshing the page loses the state so we need to fill filters again
- tricky to update all state consumers when many

solution: derive state from URL
- refreshing page keeps filtering state
- we can have as many components using the state as we want, even deeply nested

URL itself may contain state of the app like current filtering/paging info (e.g. search term, page number)

import QueryParamsSnippets from './snippet/query-params/__tabs.mdx'

<QueryParamsSnippets />

## problem: tabs on a page

challenges:
- tricky to navigate back/forward keeping active tab
- tricky to restore active tab on page refresh

solution: keep active tab id as URLs hash
- easy to share/bookmark page focused on the tab

import HashSnippets from './snippet/hash/__tabs.mdx'

<HashSnippets />
