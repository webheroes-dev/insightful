---
slug: that-is-not-a-state
title: That's not a state (anymore)
authors: [krystian, barbie]
tags: [react, state]
draft: true
---

Working with states in React can be tricky due to its volatility. That's why it's crucial 
to be aware of best practices in managing states that will make your code simple and prone to bugs.

There are many challenges related to the usage of states, 
here are some possible issues you may stumble upon while working with React states.

...

# DRAFT
- common mistakes
    - synchronizing on event
- derive from props
- derive from state
- derive from url
- opened tab id from url


<!--truncate-->

## Challenge I: you need to combine different props

React props are often synchronized to a specific state. 
Let's say you have `firstName` and `lastName` as separate strings in input, and you need to have it as a single string `FullName`.
The common mistake here would be to synchronize it with `useEffect` and `useState`.

```tsx showLineNumbers
interface Props {
    firstName: string
    lastName: string
}
function Component(props: Props) {
    const {firstName, lastName} = props

    const [fullName, setFullName] = useState()

    useEffect(() => {
        setFullName(`${firstName} ${lastName}`)
    }, [firstName, lastName])
}
```

However, there's a better solution! 
Just derive values from other props that are logically connected with each other.
Fixing it this way is often a one-line change. 

```tsx showLineNumbers
interface Props {
    firstName: string
    lastName: string
}
function Component(props: Props) {
    const {firstName, lastName} = props

    // highlight-next-line
    const fullName = `${firstName} ${lastName}` // ✨
}
```

## Challenge II: you need to combine different states

If we have several states within a component, we often need to join two states together. 
Here, as well as in the previous example, it would be common to synchronize it with `useEffect` and extra `useState`.


```tsx showLineNumbers
function Component() {
    const [firstName, setFirstName] = useState()
    const [lastName, setLastName] = useState()

    const [fullName, setFullName] = useState()

    useEffect(() => {
        setFullName(`${firstName} ${lastName}`)
    }, [firstName, lastName])
}
```
We can simplify it by deriving the value from the current state, 
if the value results from those states.

```tsx showLineNumbers
function Component() {
    const [firstName, setFirstName] = useState()
    const [lastName, setLastName] = useState()

    // highlight-next-line
    const fullName = `${firstName} ${lastName}` // ✨
}
```

## Challenge III: dealing with many related React states

Sometimes, when we have many related states, one results from the other, 
but it can have various forms. 
Let's say we're loading data for our component from an external source. 
We have a state telling us if it's loading or not (`setLoading`), a state for an error (`setError`) 
and a state for our data (`setData`). 
If it's loading, it's logical that are is no error.
Nevertheless, we need to specify each state separately.
If the query is successfull, we set our data and the loading state to `False`.
In case of an error, we specify the error value and the loading state to `False`.  

The approach described above may cause some issues. When `setData` is called, 
we should clean the `error` state.
Similarly, when `setError` is called, we should clean the `data` state.


```tsx showLineNumbers
function Component() {
    const [loading, setLoading] = useState()
    const [data, setData] = useState()
    const [error, setError] = useState()

    function load() {
        setLoading(true)

        fetch(/* ... */)
        .then((data) => {
            setData(data)
            // highlight-next-line
            setLoading(false)
        })
        .catch((error) => {
            setError(error)
            //highlight-next-line
            setLoading(false)
        })
    }
}
```

Here it should be stressed, that the issue could be even more complex and thus more difficult to solve.

```tsx showLineNumbers
function Component() {
    const [loading, setLoading] = useState()
    const [data, setData] = useState()
    const [error, setError] = useState()

    function load() {
        setLoading(true)

        fetch(/* ... */)
        .then((data) => {
            setData(data)
            setLoading(false)
            // highlight-next-line
            setError(null)
        })
        .catch((error) => {
            setError(error)
            setLoading(false)
            // highlight-next-line
            setData(null)
        })
    }
}
```

A possible solution would be to use a very underrated hook, `useReducer`, 
that could return several values at the same time.
Depending on what is our input, if we set the data, 
it would automatically swith to the loading state. 
It's basically a synchronization of multiple states - we don't need to manage them separately.  

The first parameter of the `useReducer` is a function that requires two parameters - 
the first one is the previous state, the second one is our action,
i.e. what we will use the `useReducer` with. 




```tsx showLineNumbers
const [response, setResponse] = useReducer((lastResponse, payload) => {
    if (payload === null) {
        return {
            loading: true,
            data: null,
            error: null,
        }
    } else if (payload instanceof Error) {
        return {
            loading: false,
            data: null,
            error: payload,
        }
    } else {
        return {
            loading: false,
            data: payload,
            error: null,
        }
    }
})

function load() {
    setResponse(null)

    fetch(/* ... */)
    .then((data) => setResponse(data))
    .catch((error) => setResponse(error))
}
```

It could be extremely useful, when we want to perform an action based on our previous state.
For example,
if we want to refresh a query that we have already run, 
we might want to add a loading indicator, but we still want the data to be visible.



## Challenge IV: you want to keep the filtering on a page

Imagine you filled several filters, but you then accidentally (or on purpose) refreshed the page.
And you missed it all... Sounds annoying, doesn't it? If we have many nested components, it may be quite a challenge
to preserve tha state of our filters. 

The solution would be to derive the state from the URL. Refreshing the page won't then remove our filters.
All components, no matter how deeply nested they are, will still have their filter states easily accessible.

The URL itself may contain the state of the app, like current filtering/paging info (e.g. search term, page number).


import QueryParamsSnippets from './snippet/query-params/__tabs.mdx'

<QueryParamsSnippets />

## Challenge V: dealing with multiple tabs on a page

Sometimes it can be really tricky to navigate back/forward and still keep your active tab.
The same problem occurs when you refresh a page - you simply loose the state.

However, there's a simple solution to this problem. Just keep the ID of the active tab as a hash in the URL.
You can then easily share/bookmark a link to a specific tab and place in the application.


import HashSnippets from './snippet/hash/__tabs.mdx'

<HashSnippets />
